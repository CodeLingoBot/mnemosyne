// Code generated by protoc-gen-go.
// source: mnemosyne.proto
// DO NOT EDIT!

/*
Package shared is a generated protocol buffer package.

It is generated from these files:
	mnemosyne.proto

It has these top-level messages:
	ID
	Session
	GetRequest
	GetResponse
	ListRequest
	ListResponse
	ExistsRequest
	ExistsResponse
	CreateRequest
	CreateResponse
	AbandonRequest
	AbandonResponse
	SetDataRequest
	SetDataResponse
	DeleteRequest
	DeleteResponse
*/
package shared

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type ID struct {
	Key  string `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	Hash string `protobuf:"bytes,2,opt,name=hash" json:"hash,omitempty"`
}

func (m *ID) Reset()         { *m = ID{} }
func (m *ID) String() string { return proto.CompactTextString(m) }
func (*ID) ProtoMessage()    {}

type Session struct {
	Id       *ID               `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Data     map[string]string `protobuf:"bytes,2,rep,name=data" json:"data,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	ExpireAt string            `protobuf:"bytes,3,opt,name=expire_at" json:"expire_at,omitempty"`
}

func (m *Session) Reset()         { *m = Session{} }
func (m *Session) String() string { return proto.CompactTextString(m) }
func (*Session) ProtoMessage()    {}

func (m *Session) GetId() *ID {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *Session) GetData() map[string]string {
	if m != nil {
		return m.Data
	}
	return nil
}

type GetRequest struct {
	Id *ID `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
}

func (m *GetRequest) Reset()         { *m = GetRequest{} }
func (m *GetRequest) String() string { return proto.CompactTextString(m) }
func (*GetRequest) ProtoMessage()    {}

func (m *GetRequest) GetId() *ID {
	if m != nil {
		return m.Id
	}
	return nil
}

type GetResponse struct {
	Session *Session `protobuf:"bytes,1,opt,name=session" json:"session,omitempty"`
}

func (m *GetResponse) Reset()         { *m = GetResponse{} }
func (m *GetResponse) String() string { return proto.CompactTextString(m) }
func (*GetResponse) ProtoMessage()    {}

func (m *GetResponse) GetSession() *Session {
	if m != nil {
		return m.Session
	}
	return nil
}

type ListRequest struct {
	Offset       int64  `protobuf:"varint,1,opt,name=offset" json:"offset,omitempty"`
	Limit        int64  `protobuf:"varint,2,opt,name=limit" json:"limit,omitempty"`
	ExpireAtFrom string `protobuf:"bytes,3,opt,name=expire_at_from" json:"expire_at_from,omitempty"`
	ExpireAtTo   string `protobuf:"bytes,4,opt,name=expire_at_to" json:"expire_at_to,omitempty"`
}

func (m *ListRequest) Reset()         { *m = ListRequest{} }
func (m *ListRequest) String() string { return proto.CompactTextString(m) }
func (*ListRequest) ProtoMessage()    {}

type ListResponse struct {
	Sessions []*Session `protobuf:"bytes,1,rep,name=sessions" json:"sessions,omitempty"`
}

func (m *ListResponse) Reset()         { *m = ListResponse{} }
func (m *ListResponse) String() string { return proto.CompactTextString(m) }
func (*ListResponse) ProtoMessage()    {}

func (m *ListResponse) GetSessions() []*Session {
	if m != nil {
		return m.Sessions
	}
	return nil
}

type ExistsRequest struct {
	Id *ID `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
}

func (m *ExistsRequest) Reset()         { *m = ExistsRequest{} }
func (m *ExistsRequest) String() string { return proto.CompactTextString(m) }
func (*ExistsRequest) ProtoMessage()    {}

func (m *ExistsRequest) GetId() *ID {
	if m != nil {
		return m.Id
	}
	return nil
}

type ExistsResponse struct {
	Exists bool `protobuf:"varint,1,opt,name=exists" json:"exists,omitempty"`
}

func (m *ExistsResponse) Reset()         { *m = ExistsResponse{} }
func (m *ExistsResponse) String() string { return proto.CompactTextString(m) }
func (*ExistsResponse) ProtoMessage()    {}

type CreateRequest struct {
	Data map[string]string `protobuf:"bytes,1,rep,name=data" json:"data,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *CreateRequest) Reset()         { *m = CreateRequest{} }
func (m *CreateRequest) String() string { return proto.CompactTextString(m) }
func (*CreateRequest) ProtoMessage()    {}

func (m *CreateRequest) GetData() map[string]string {
	if m != nil {
		return m.Data
	}
	return nil
}

type CreateResponse struct {
	Session *Session `protobuf:"bytes,1,opt,name=session" json:"session,omitempty"`
}

func (m *CreateResponse) Reset()         { *m = CreateResponse{} }
func (m *CreateResponse) String() string { return proto.CompactTextString(m) }
func (*CreateResponse) ProtoMessage()    {}

func (m *CreateResponse) GetSession() *Session {
	if m != nil {
		return m.Session
	}
	return nil
}

type AbandonRequest struct {
	Id *ID `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
}

func (m *AbandonRequest) Reset()         { *m = AbandonRequest{} }
func (m *AbandonRequest) String() string { return proto.CompactTextString(m) }
func (*AbandonRequest) ProtoMessage()    {}

func (m *AbandonRequest) GetId() *ID {
	if m != nil {
		return m.Id
	}
	return nil
}

type AbandonResponse struct {
	Abandoned bool `protobuf:"varint,1,opt,name=abandoned" json:"abandoned,omitempty"`
}

func (m *AbandonResponse) Reset()         { *m = AbandonResponse{} }
func (m *AbandonResponse) String() string { return proto.CompactTextString(m) }
func (*AbandonResponse) ProtoMessage()    {}

type SetDataRequest struct {
	Id    *ID    `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Key   string `protobuf:"bytes,2,opt,name=key" json:"key,omitempty"`
	Value string `protobuf:"bytes,3,opt,name=value" json:"value,omitempty"`
}

func (m *SetDataRequest) Reset()         { *m = SetDataRequest{} }
func (m *SetDataRequest) String() string { return proto.CompactTextString(m) }
func (*SetDataRequest) ProtoMessage()    {}

func (m *SetDataRequest) GetId() *ID {
	if m != nil {
		return m.Id
	}
	return nil
}

type SetDataResponse struct {
	Session *Session `protobuf:"bytes,1,opt,name=session" json:"session,omitempty"`
}

func (m *SetDataResponse) Reset()         { *m = SetDataResponse{} }
func (m *SetDataResponse) String() string { return proto.CompactTextString(m) }
func (*SetDataResponse) ProtoMessage()    {}

func (m *SetDataResponse) GetSession() *Session {
	if m != nil {
		return m.Session
	}
	return nil
}

type DeleteRequest struct {
	Id           *ID    `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	ExpireAtFrom string `protobuf:"bytes,2,opt,name=expire_at_from" json:"expire_at_from,omitempty"`
	ExpireAtTo   string `protobuf:"bytes,3,opt,name=expire_at_to" json:"expire_at_to,omitempty"`
}

func (m *DeleteRequest) Reset()         { *m = DeleteRequest{} }
func (m *DeleteRequest) String() string { return proto.CompactTextString(m) }
func (*DeleteRequest) ProtoMessage()    {}

func (m *DeleteRequest) GetId() *ID {
	if m != nil {
		return m.Id
	}
	return nil
}

type DeleteResponse struct {
	Count int64 `protobuf:"varint,1,opt,name=count" json:"count,omitempty"`
}

func (m *DeleteResponse) Reset()         { *m = DeleteResponse{} }
func (m *DeleteResponse) String() string { return proto.CompactTextString(m) }
func (*DeleteResponse) ProtoMessage()    {}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// Client API for Mnemosyne service

type MnemosyneClient interface {
	Get(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (*GetResponse, error)
	List(ctx context.Context, in *ListRequest, opts ...grpc.CallOption) (*ListResponse, error)
	Exists(ctx context.Context, in *ExistsRequest, opts ...grpc.CallOption) (*ExistsResponse, error)
	Create(ctx context.Context, in *CreateRequest, opts ...grpc.CallOption) (*CreateResponse, error)
	Abandon(ctx context.Context, in *AbandonRequest, opts ...grpc.CallOption) (*AbandonResponse, error)
	SetData(ctx context.Context, in *SetDataRequest, opts ...grpc.CallOption) (*SetDataResponse, error)
	Delete(ctx context.Context, in *DeleteRequest, opts ...grpc.CallOption) (*DeleteResponse, error)
}

type mnemosyneClient struct {
	cc *grpc.ClientConn
}

func NewMnemosyneClient(cc *grpc.ClientConn) MnemosyneClient {
	return &mnemosyneClient{cc}
}

func (c *mnemosyneClient) Get(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (*GetResponse, error) {
	out := new(GetResponse)
	err := grpc.Invoke(ctx, "/shared.Mnemosyne/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mnemosyneClient) List(ctx context.Context, in *ListRequest, opts ...grpc.CallOption) (*ListResponse, error) {
	out := new(ListResponse)
	err := grpc.Invoke(ctx, "/shared.Mnemosyne/List", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mnemosyneClient) Exists(ctx context.Context, in *ExistsRequest, opts ...grpc.CallOption) (*ExistsResponse, error) {
	out := new(ExistsResponse)
	err := grpc.Invoke(ctx, "/shared.Mnemosyne/Exists", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mnemosyneClient) Create(ctx context.Context, in *CreateRequest, opts ...grpc.CallOption) (*CreateResponse, error) {
	out := new(CreateResponse)
	err := grpc.Invoke(ctx, "/shared.Mnemosyne/Create", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mnemosyneClient) Abandon(ctx context.Context, in *AbandonRequest, opts ...grpc.CallOption) (*AbandonResponse, error) {
	out := new(AbandonResponse)
	err := grpc.Invoke(ctx, "/shared.Mnemosyne/Abandon", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mnemosyneClient) SetData(ctx context.Context, in *SetDataRequest, opts ...grpc.CallOption) (*SetDataResponse, error) {
	out := new(SetDataResponse)
	err := grpc.Invoke(ctx, "/shared.Mnemosyne/SetData", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mnemosyneClient) Delete(ctx context.Context, in *DeleteRequest, opts ...grpc.CallOption) (*DeleteResponse, error) {
	out := new(DeleteResponse)
	err := grpc.Invoke(ctx, "/shared.Mnemosyne/Delete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Mnemosyne service

type MnemosyneServer interface {
	Get(context.Context, *GetRequest) (*GetResponse, error)
	List(context.Context, *ListRequest) (*ListResponse, error)
	Exists(context.Context, *ExistsRequest) (*ExistsResponse, error)
	Create(context.Context, *CreateRequest) (*CreateResponse, error)
	Abandon(context.Context, *AbandonRequest) (*AbandonResponse, error)
	SetData(context.Context, *SetDataRequest) (*SetDataResponse, error)
	Delete(context.Context, *DeleteRequest) (*DeleteResponse, error)
}

func RegisterMnemosyneServer(s *grpc.Server, srv MnemosyneServer) {
	s.RegisterService(&_Mnemosyne_serviceDesc, srv)
}

func _Mnemosyne_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(GetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(MnemosyneServer).Get(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Mnemosyne_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(ListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(MnemosyneServer).List(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Mnemosyne_Exists_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(ExistsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(MnemosyneServer).Exists(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Mnemosyne_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(CreateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(MnemosyneServer).Create(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Mnemosyne_Abandon_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(AbandonRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(MnemosyneServer).Abandon(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Mnemosyne_SetData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(SetDataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(MnemosyneServer).SetData(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Mnemosyne_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(DeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(MnemosyneServer).Delete(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _Mnemosyne_serviceDesc = grpc.ServiceDesc{
	ServiceName: "shared.Mnemosyne",
	HandlerType: (*MnemosyneServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _Mnemosyne_Get_Handler,
		},
		{
			MethodName: "List",
			Handler:    _Mnemosyne_List_Handler,
		},
		{
			MethodName: "Exists",
			Handler:    _Mnemosyne_Exists_Handler,
		},
		{
			MethodName: "Create",
			Handler:    _Mnemosyne_Create_Handler,
		},
		{
			MethodName: "Abandon",
			Handler:    _Mnemosyne_Abandon_Handler,
		},
		{
			MethodName: "SetData",
			Handler:    _Mnemosyne_SetData_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _Mnemosyne_Delete_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}
