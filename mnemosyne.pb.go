// Code generated by protoc-gen-go.
// source: mnemosyne.proto
// DO NOT EDIT!

/*
Package mnemosyne is a generated protocol buffer package.

It is generated from these files:
	mnemosyne.proto

It has these top-level messages:
	Token
	Session
	GetRequest
	GetResponse
	ListRequest
	ListResponse
	ExistsRequest
	ExistsResponse
	StartRequest
	StartResponse
	AbandonRequest
	AbandonResponse
	SetValueRequest
	SetValueResponse
	DeleteValueRequest
	DeleteValueResponse
	ClearRequest
	ClearResponse
	DeleteRequest
	DeleteResponse
*/
package mnemosyne

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import protot "github.com/piotrkowalczuk/protot"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Token represents identifier of single session. It consist of partition key and a hash.
type Token struct {
	Key  string `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	Hash string `protobuf:"bytes,2,opt,name=hash" json:"hash,omitempty"`
}

func (m *Token) Reset()         { *m = Token{} }
func (m *Token) String() string { return proto.CompactTextString(m) }
func (*Token) ProtoMessage()    {}

type Session struct {
	Token     *Token            `protobuf:"bytes,1,opt,name=token" json:"token,omitempty"`
	SubjectId string            `protobuf:"bytes,2,opt,name=subject_id" json:"subject_id,omitempty"`
	Bag       map[string]string `protobuf:"bytes,3,rep,name=bag" json:"bag,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	ExpireAt  *protot.Timestamp `protobuf:"bytes,4,opt,name=expire_at" json:"expire_at,omitempty"`
}

func (m *Session) Reset()         { *m = Session{} }
func (m *Session) String() string { return proto.CompactTextString(m) }
func (*Session) ProtoMessage()    {}

func (m *Session) GetToken() *Token {
	if m != nil {
		return m.Token
	}
	return nil
}

func (m *Session) GetBag() map[string]string {
	if m != nil {
		return m.Bag
	}
	return nil
}

func (m *Session) GetExpireAt() *protot.Timestamp {
	if m != nil {
		return m.ExpireAt
	}
	return nil
}

type GetRequest struct {
	Token *Token `protobuf:"bytes,1,opt,name=token" json:"token,omitempty"`
}

func (m *GetRequest) Reset()         { *m = GetRequest{} }
func (m *GetRequest) String() string { return proto.CompactTextString(m) }
func (*GetRequest) ProtoMessage()    {}

func (m *GetRequest) GetToken() *Token {
	if m != nil {
		return m.Token
	}
	return nil
}

type GetResponse struct {
	Session *Session `protobuf:"bytes,1,opt,name=session" json:"session,omitempty"`
}

func (m *GetResponse) Reset()         { *m = GetResponse{} }
func (m *GetResponse) String() string { return proto.CompactTextString(m) }
func (*GetResponse) ProtoMessage()    {}

func (m *GetResponse) GetSession() *Session {
	if m != nil {
		return m.Session
	}
	return nil
}

type ListRequest struct {
	Offset       int64             `protobuf:"varint,1,opt,name=offset" json:"offset,omitempty"`
	Limit        int64             `protobuf:"varint,2,opt,name=limit" json:"limit,omitempty"`
	ExpireAtFrom *protot.Timestamp `protobuf:"bytes,3,opt,name=expire_at_from" json:"expire_at_from,omitempty"`
	ExpireAtTo   *protot.Timestamp `protobuf:"bytes,4,opt,name=expire_at_to" json:"expire_at_to,omitempty"`
}

func (m *ListRequest) Reset()         { *m = ListRequest{} }
func (m *ListRequest) String() string { return proto.CompactTextString(m) }
func (*ListRequest) ProtoMessage()    {}

func (m *ListRequest) GetExpireAtFrom() *protot.Timestamp {
	if m != nil {
		return m.ExpireAtFrom
	}
	return nil
}

func (m *ListRequest) GetExpireAtTo() *protot.Timestamp {
	if m != nil {
		return m.ExpireAtTo
	}
	return nil
}

type ListResponse struct {
	Sessions []*Session `protobuf:"bytes,1,rep,name=sessions" json:"sessions,omitempty"`
}

func (m *ListResponse) Reset()         { *m = ListResponse{} }
func (m *ListResponse) String() string { return proto.CompactTextString(m) }
func (*ListResponse) ProtoMessage()    {}

func (m *ListResponse) GetSessions() []*Session {
	if m != nil {
		return m.Sessions
	}
	return nil
}

type ExistsRequest struct {
	Token *Token `protobuf:"bytes,1,opt,name=token" json:"token,omitempty"`
}

func (m *ExistsRequest) Reset()         { *m = ExistsRequest{} }
func (m *ExistsRequest) String() string { return proto.CompactTextString(m) }
func (*ExistsRequest) ProtoMessage()    {}

func (m *ExistsRequest) GetToken() *Token {
	if m != nil {
		return m.Token
	}
	return nil
}

type ExistsResponse struct {
	Exists bool `protobuf:"varint,1,opt,name=exists" json:"exists,omitempty"`
}

func (m *ExistsResponse) Reset()         { *m = ExistsResponse{} }
func (m *ExistsResponse) String() string { return proto.CompactTextString(m) }
func (*ExistsResponse) ProtoMessage()    {}

type StartRequest struct {
	SubjectId string            `protobuf:"bytes,1,opt,name=subject_id" json:"subject_id,omitempty"`
	Bag       map[string]string `protobuf:"bytes,2,rep,name=bag" json:"bag,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *StartRequest) Reset()         { *m = StartRequest{} }
func (m *StartRequest) String() string { return proto.CompactTextString(m) }
func (*StartRequest) ProtoMessage()    {}

func (m *StartRequest) GetBag() map[string]string {
	if m != nil {
		return m.Bag
	}
	return nil
}

type StartResponse struct {
	Session *Session `protobuf:"bytes,1,opt,name=session" json:"session,omitempty"`
}

func (m *StartResponse) Reset()         { *m = StartResponse{} }
func (m *StartResponse) String() string { return proto.CompactTextString(m) }
func (*StartResponse) ProtoMessage()    {}

func (m *StartResponse) GetSession() *Session {
	if m != nil {
		return m.Session
	}
	return nil
}

type AbandonRequest struct {
	Token *Token `protobuf:"bytes,1,opt,name=token" json:"token,omitempty"`
}

func (m *AbandonRequest) Reset()         { *m = AbandonRequest{} }
func (m *AbandonRequest) String() string { return proto.CompactTextString(m) }
func (*AbandonRequest) ProtoMessage()    {}

func (m *AbandonRequest) GetToken() *Token {
	if m != nil {
		return m.Token
	}
	return nil
}

type AbandonResponse struct {
	Abandoned bool `protobuf:"varint,1,opt,name=abandoned" json:"abandoned,omitempty"`
}

func (m *AbandonResponse) Reset()         { *m = AbandonResponse{} }
func (m *AbandonResponse) String() string { return proto.CompactTextString(m) }
func (*AbandonResponse) ProtoMessage()    {}

type SetValueRequest struct {
	Token *Token `protobuf:"bytes,1,opt,name=token" json:"token,omitempty"`
	Key   string `protobuf:"bytes,2,opt,name=key" json:"key,omitempty"`
	Value string `protobuf:"bytes,3,opt,name=value" json:"value,omitempty"`
}

func (m *SetValueRequest) Reset()         { *m = SetValueRequest{} }
func (m *SetValueRequest) String() string { return proto.CompactTextString(m) }
func (*SetValueRequest) ProtoMessage()    {}

func (m *SetValueRequest) GetToken() *Token {
	if m != nil {
		return m.Token
	}
	return nil
}

type SetValueResponse struct {
	Session *Session `protobuf:"bytes,1,opt,name=session" json:"session,omitempty"`
}

func (m *SetValueResponse) Reset()         { *m = SetValueResponse{} }
func (m *SetValueResponse) String() string { return proto.CompactTextString(m) }
func (*SetValueResponse) ProtoMessage()    {}

func (m *SetValueResponse) GetSession() *Session {
	if m != nil {
		return m.Session
	}
	return nil
}

type DeleteValueRequest struct {
	Token *Token `protobuf:"bytes,1,opt,name=token" json:"token,omitempty"`
	Key   string `protobuf:"bytes,2,opt,name=key" json:"key,omitempty"`
}

func (m *DeleteValueRequest) Reset()         { *m = DeleteValueRequest{} }
func (m *DeleteValueRequest) String() string { return proto.CompactTextString(m) }
func (*DeleteValueRequest) ProtoMessage()    {}

func (m *DeleteValueRequest) GetToken() *Token {
	if m != nil {
		return m.Token
	}
	return nil
}

type DeleteValueResponse struct {
	Session *Session `protobuf:"bytes,1,opt,name=session" json:"session,omitempty"`
}

func (m *DeleteValueResponse) Reset()         { *m = DeleteValueResponse{} }
func (m *DeleteValueResponse) String() string { return proto.CompactTextString(m) }
func (*DeleteValueResponse) ProtoMessage()    {}

func (m *DeleteValueResponse) GetSession() *Session {
	if m != nil {
		return m.Session
	}
	return nil
}

type ClearRequest struct {
	Token *Token `protobuf:"bytes,1,opt,name=token" json:"token,omitempty"`
}

func (m *ClearRequest) Reset()         { *m = ClearRequest{} }
func (m *ClearRequest) String() string { return proto.CompactTextString(m) }
func (*ClearRequest) ProtoMessage()    {}

func (m *ClearRequest) GetToken() *Token {
	if m != nil {
		return m.Token
	}
	return nil
}

type ClearResponse struct {
}

func (m *ClearResponse) Reset()         { *m = ClearResponse{} }
func (m *ClearResponse) String() string { return proto.CompactTextString(m) }
func (*ClearResponse) ProtoMessage()    {}

type DeleteRequest struct {
	Token        *Token            `protobuf:"bytes,1,opt,name=token" json:"token,omitempty"`
	ExpireAtFrom *protot.Timestamp `protobuf:"bytes,2,opt,name=expire_at_from" json:"expire_at_from,omitempty"`
	ExpireAtTo   *protot.Timestamp `protobuf:"bytes,3,opt,name=expire_at_to" json:"expire_at_to,omitempty"`
}

func (m *DeleteRequest) Reset()         { *m = DeleteRequest{} }
func (m *DeleteRequest) String() string { return proto.CompactTextString(m) }
func (*DeleteRequest) ProtoMessage()    {}

func (m *DeleteRequest) GetToken() *Token {
	if m != nil {
		return m.Token
	}
	return nil
}

func (m *DeleteRequest) GetExpireAtFrom() *protot.Timestamp {
	if m != nil {
		return m.ExpireAtFrom
	}
	return nil
}

func (m *DeleteRequest) GetExpireAtTo() *protot.Timestamp {
	if m != nil {
		return m.ExpireAtTo
	}
	return nil
}

type DeleteResponse struct {
	Count int64 `protobuf:"varint,1,opt,name=count" json:"count,omitempty"`
}

func (m *DeleteResponse) Reset()         { *m = DeleteResponse{} }
func (m *DeleteResponse) String() string { return proto.CompactTextString(m) }
func (*DeleteResponse) ProtoMessage()    {}

func init() {
	proto.RegisterType((*Token)(nil), "mnemosyne.Token")
	proto.RegisterType((*Session)(nil), "mnemosyne.Session")
	proto.RegisterType((*GetRequest)(nil), "mnemosyne.GetRequest")
	proto.RegisterType((*GetResponse)(nil), "mnemosyne.GetResponse")
	proto.RegisterType((*ListRequest)(nil), "mnemosyne.ListRequest")
	proto.RegisterType((*ListResponse)(nil), "mnemosyne.ListResponse")
	proto.RegisterType((*ExistsRequest)(nil), "mnemosyne.ExistsRequest")
	proto.RegisterType((*ExistsResponse)(nil), "mnemosyne.ExistsResponse")
	proto.RegisterType((*StartRequest)(nil), "mnemosyne.StartRequest")
	proto.RegisterType((*StartResponse)(nil), "mnemosyne.StartResponse")
	proto.RegisterType((*AbandonRequest)(nil), "mnemosyne.AbandonRequest")
	proto.RegisterType((*AbandonResponse)(nil), "mnemosyne.AbandonResponse")
	proto.RegisterType((*SetValueRequest)(nil), "mnemosyne.SetValueRequest")
	proto.RegisterType((*SetValueResponse)(nil), "mnemosyne.SetValueResponse")
	proto.RegisterType((*DeleteValueRequest)(nil), "mnemosyne.DeleteValueRequest")
	proto.RegisterType((*DeleteValueResponse)(nil), "mnemosyne.DeleteValueResponse")
	proto.RegisterType((*ClearRequest)(nil), "mnemosyne.ClearRequest")
	proto.RegisterType((*ClearResponse)(nil), "mnemosyne.ClearResponse")
	proto.RegisterType((*DeleteRequest)(nil), "mnemosyne.DeleteRequest")
	proto.RegisterType((*DeleteResponse)(nil), "mnemosyne.DeleteResponse")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// Client API for RPC service

type RPCClient interface {
	Get(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (*GetResponse, error)
	List(ctx context.Context, in *ListRequest, opts ...grpc.CallOption) (*ListResponse, error)
	Exists(ctx context.Context, in *ExistsRequest, opts ...grpc.CallOption) (*ExistsResponse, error)
	Start(ctx context.Context, in *StartRequest, opts ...grpc.CallOption) (*StartResponse, error)
	Abandon(ctx context.Context, in *AbandonRequest, opts ...grpc.CallOption) (*AbandonResponse, error)
	SetValue(ctx context.Context, in *SetValueRequest, opts ...grpc.CallOption) (*SetValueResponse, error)
	//    rpc DeleteValue(DeleteValueRequest) returns (DeleteValueResponse) {};
	//    rpc Clear(ClearRequest) returns (ClearResponse) {};
	Delete(ctx context.Context, in *DeleteRequest, opts ...grpc.CallOption) (*DeleteResponse, error)
}

type rPCClient struct {
	cc *grpc.ClientConn
}

func NewRPCClient(cc *grpc.ClientConn) RPCClient {
	return &rPCClient{cc}
}

func (c *rPCClient) Get(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (*GetResponse, error) {
	out := new(GetResponse)
	err := grpc.Invoke(ctx, "/mnemosyne.RPC/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCClient) List(ctx context.Context, in *ListRequest, opts ...grpc.CallOption) (*ListResponse, error) {
	out := new(ListResponse)
	err := grpc.Invoke(ctx, "/mnemosyne.RPC/List", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCClient) Exists(ctx context.Context, in *ExistsRequest, opts ...grpc.CallOption) (*ExistsResponse, error) {
	out := new(ExistsResponse)
	err := grpc.Invoke(ctx, "/mnemosyne.RPC/Exists", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCClient) Start(ctx context.Context, in *StartRequest, opts ...grpc.CallOption) (*StartResponse, error) {
	out := new(StartResponse)
	err := grpc.Invoke(ctx, "/mnemosyne.RPC/Start", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCClient) Abandon(ctx context.Context, in *AbandonRequest, opts ...grpc.CallOption) (*AbandonResponse, error) {
	out := new(AbandonResponse)
	err := grpc.Invoke(ctx, "/mnemosyne.RPC/Abandon", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCClient) SetValue(ctx context.Context, in *SetValueRequest, opts ...grpc.CallOption) (*SetValueResponse, error) {
	out := new(SetValueResponse)
	err := grpc.Invoke(ctx, "/mnemosyne.RPC/SetValue", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCClient) Delete(ctx context.Context, in *DeleteRequest, opts ...grpc.CallOption) (*DeleteResponse, error) {
	out := new(DeleteResponse)
	err := grpc.Invoke(ctx, "/mnemosyne.RPC/Delete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for RPC service

type RPCServer interface {
	Get(context.Context, *GetRequest) (*GetResponse, error)
	List(context.Context, *ListRequest) (*ListResponse, error)
	Exists(context.Context, *ExistsRequest) (*ExistsResponse, error)
	Start(context.Context, *StartRequest) (*StartResponse, error)
	Abandon(context.Context, *AbandonRequest) (*AbandonResponse, error)
	SetValue(context.Context, *SetValueRequest) (*SetValueResponse, error)
	//    rpc DeleteValue(DeleteValueRequest) returns (DeleteValueResponse) {};
	//    rpc Clear(ClearRequest) returns (ClearResponse) {};
	Delete(context.Context, *DeleteRequest) (*DeleteResponse, error)
}

func RegisterRPCServer(s *grpc.Server, srv RPCServer) {
	s.RegisterService(&_RPC_serviceDesc, srv)
}

func _RPC_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(GetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(RPCServer).Get(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _RPC_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(ListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(RPCServer).List(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _RPC_Exists_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(ExistsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(RPCServer).Exists(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _RPC_Start_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(StartRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(RPCServer).Start(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _RPC_Abandon_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(AbandonRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(RPCServer).Abandon(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _RPC_SetValue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(SetValueRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(RPCServer).SetValue(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _RPC_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(DeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(RPCServer).Delete(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _RPC_serviceDesc = grpc.ServiceDesc{
	ServiceName: "mnemosyne.RPC",
	HandlerType: (*RPCServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _RPC_Get_Handler,
		},
		{
			MethodName: "List",
			Handler:    _RPC_List_Handler,
		},
		{
			MethodName: "Exists",
			Handler:    _RPC_Exists_Handler,
		},
		{
			MethodName: "Start",
			Handler:    _RPC_Start_Handler,
		},
		{
			MethodName: "Abandon",
			Handler:    _RPC_Abandon_Handler,
		},
		{
			MethodName: "SetValue",
			Handler:    _RPC_SetValue_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _RPC_Delete_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}
